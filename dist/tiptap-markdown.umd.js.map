{"version":3,"file":"tiptap-markdown.umd.js","sources":["../src/extensions/tiptap/tight-lists.js","../src/util/markdown.js","../src/serialize/state.js","../src/extensions/marks/html.js","../src/util/dom.js","../src/extensions/nodes/html.js","../src/extensions/nodes/blockquote.js","../src/extensions/nodes/bullet-list.js","../src/extensions/nodes/code-block.js","../src/extensions/nodes/hard-break.js","../src/extensions/nodes/heading.js","../src/extensions/nodes/horizontal-rule.js","../src/extensions/nodes/image.js","../src/extensions/nodes/list-item.js","../src/extensions/nodes/ordered-list.js","../src/extensions/nodes/paragraph.js","../src/util/prosemirror.js","../src/extensions/nodes/table.js","../src/extensions/nodes/text.js","../src/extensions/marks/bold.js","../src/extensions/marks/code.js","../src/extensions/marks/italic.js","../src/extensions/marks/link.js","../src/extensions/marks/strike.js","../src/extensions/index.js","../src/util/extensions.js","../src/serialize/MarkdownSerializer.js","../src/parse/MarkdownParser.js","../src/extensions/tiptap/clipboard.js","../src/Markdown.js"],"sourcesContent":["import { Extension } from \"@tiptap/core\";\n\nexport const MarkdownTightLists = Extension.create({\n    name: 'markdownTightLists',\n    addOptions: () => ({\n        tight: true,\n        tightClass: 'tight',\n        listTypes: [\n            'bulletList',\n            'orderedList',\n        ],\n    }),\n    addGlobalAttributes() {\n        return [\n            {\n                types: this.options.listTypes,\n                attributes: {\n                    tight: {\n                        default: this.options.tight,\n                        parseHTML: element =>\n                            element.getAttribute('data-tight') === 'true' || !element.querySelector('p'),\n                        renderHTML: attributes => ({\n                            class: attributes.tight ? this.options.tightClass : null,\n                            'data-tight': attributes.tight ? 'true' : null,\n                        }),\n                    },\n                },\n            },\n        ]\n    },\n    addCommands() {\n        return {\n            toggleTight: (tight = null) => ({ editor, commands }) => {\n                function toggleTight(name) {\n                    if(!editor.isActive(name)) {\n                        return false;\n                    }\n                    const attrs = editor.getAttributes(name);\n                    return commands.updateAttributes(name, {\n                        tight: tight ?? !attrs?.tight,\n                    });\n                }\n                return this.options.listTypes\n                    .some(name => toggleTight(name));\n            }\n        }\n    },\n});\n","import { marked } from 'marked';\n\n// Use a symbol for private properties\nconst parserSymbol = Symbol('markedParser');\n\n// Cleanup global function\nlet globalCleanupScheduled = false;\n\n/**\n * Get the marked parser singleton - lazily initialized\n */\nexport function getMarkedParser() {\n    // Only create if needed and return wrapped functions, not the instance\n    if (!globalThis[parserSymbol]) {\n        const wrapAndClean = (fn) => {\n            return (...args) => {\n                try {\n                    return fn(...args);\n                } finally {\n                    // Schedule cleanup after processing is done\n                    if (!globalCleanupScheduled) {\n                        globalCleanupScheduled = true;\n                        setTimeout(() => {\n                            // Clear parser if no active usage\n                            if (globalThis[parserSymbol] && !document.querySelector('.ProseMirror')) {\n                                cleanupMarkedParser();\n                            }\n                            globalCleanupScheduled = false;\n                        }, 5000);\n                    }\n                }\n            };\n        };\n\n        globalThis[parserSymbol] = {\n            parse: wrapAndClean(marked.parse),\n            parseInline: wrapAndClean(marked.parseInline)\n        };\n    }\n    return globalThis[parserSymbol];\n}\n\n/**\n * Clean up the marked parser\n */\nexport function cleanupMarkedParser() {\n    if (globalThis[parserSymbol]) {\n        globalThis[parserSymbol] = null;\n    }\n}\n\n/**\n * Optimized delimiter check\n * This combines the can_open and can_close checks from CommonMark spec\n * \n * @param {string} text - The text to check\n * @param {number} pos - Position of the delimiter\n * @param {boolean} isOpening - Whether it's an opening or closing delimiter\n * @returns {boolean} Whether the delimiter can be used\n */\nexport function canDelimiterBeUsed(text, pos, isOpening) {\n    if (!text || pos < 0 || pos >= text.length) return false;\n    \n    const char = text.charAt(pos);\n    \n    // Fast checks for edge cases\n    if (pos === 0) return isOpening;\n    if (pos === text.length - 1) return !isOpening;\n    \n    // Get the surrounding characters using charCodeAt for performance\n    const prevCharCode = text.charCodeAt(pos - 1);\n    const nextCharCode = text.charCodeAt(pos + 1);\n    \n    // Whitespace check using character codes (faster than regex)\n    const isPrevWhitespace = prevCharCode <= 32; // space or control char\n    const isNextWhitespace = nextCharCode <= 32;\n    \n    // Punctuation check using character ranges (faster than regex)\n    const isPrevPunctuation = isPunctuation(prevCharCode);\n    const isNextPunctuation = isPunctuation(nextCharCode);\n    \n    // Efficient implementation of CommonMark rules\n    if (isOpening) {\n        // For opening, we need left-flanking\n        return !isNextWhitespace && (!isNextPunctuation || isPrevWhitespace || isPrevPunctuation);\n    } else {\n        // For closing, we need right-flanking\n        return !isPrevWhitespace && (!isPrevPunctuation || isNextWhitespace || isNextPunctuation);\n    }\n}\n\n/**\n * Fast punctuation check\n * @param {number} charCode \n * @returns {boolean}\n */\nfunction isPunctuation(charCode) {\n    // Check if character is punctuation using character codes\n    return (charCode >= 33 && charCode <= 47) ||   // ! \" # $ % & ' ( ) * + , - . /\n           (charCode >= 58 && charCode <= 64) ||   // : ; < = > ? @\n           (charCode >= 91 && charCode <= 96) ||   // [ \\ ] ^ _ `\n           (charCode >= 123 && charCode <= 126);   // { | } ~\n}\n\n/**\n * Optimized delim shifting\n * @param {string} text\n * @param {string} delim\n * @param {number} start\n * @param {number} offset\n * @returns {string}\n */\nexport function shiftDelim(text, delim, start, offset) {\n    // Use substring operations for better performance\n    // This avoids creating too many intermediate strings\n    return text.substring(0, start) + \n           text.substring(start + delim.length, start + offset) + \n           delim + \n           text.substring(start + offset);\n}\n\n/**\n * Optimized trim start function\n */\nfunction trimStart(text, delim, from, to) {\n    if (from >= to) return { text, from, to };\n    \n    let pos = from, res = text;\n    // Limit iterations to prevent potential infinite loops\n    const maxIterations = to - from;\n    let iterations = 0;\n    \n    while (pos < to && iterations < maxIterations) {\n        if (canDelimiterBeUsed(res, pos, true)) {\n            break;\n        }\n        res = shiftDelim(res, delim, pos, 1);\n        pos++;\n        iterations++;\n    }\n    \n    return { text: res, from: pos, to };\n}\n\n/**\n * Optimized trim end function\n */\nfunction trimEnd(text, delim, from, to) {\n    if (from >= to) return { text, from, to };\n    \n    let pos = to, res = text;\n    // Limit iterations to prevent potential infinite loops\n    const maxIterations = to - from;\n    let iterations = 0;\n    \n    while (pos > from && iterations < maxIterations) {\n        if (canDelimiterBeUsed(res, pos, false)) {\n            break;\n        }\n        res = shiftDelim(res, delim, pos, -1);\n        pos--;\n        iterations++;\n    }\n    \n    return { text: res, from, to: pos };\n}\n\n/**\n * Optimized string manipulation for inline markdown\n * @param {string} text - Input text\n * @param {string} delim - Delimiter\n * @param {number} from - Start position\n * @param {number} to - End position\n * @returns {string}\n */\nexport function trimInline(text, delim, from, to) {\n    if (!text || from < 0 || to >= text.length || from >= to) {\n        return text;\n    }\n    \n    try {\n        let state = { text, from, to };\n        \n        // Apply trimming operations\n        state = trimStart(state.text, delim, state.from, state.to);\n        state = trimEnd(state.text, delim, state.from, state.to);\n        \n        // Check if we need to remove the inline markup entirely\n        if (state.to - state.from < delim.length + 1) {\n            state.text = state.text.substring(0, state.from) + \n                         state.text.substring(state.to + delim.length);\n        }\n        \n        return state.text;\n    } catch (e) {\n        console.error('Error in trimInline:', e);\n        return text;\n    }\n}\n","import { MarkdownSerializerState as BaseMarkdownSerializerState } from \"prosemirror-markdown\";\nimport { trimInline } from \"../util/markdown\";\n\n\n/**\n * Override default MarkdownSerializerState to:\n * - handle commonmark delimiters (https://spec.commonmark.org/0.29/#left-flanking-delimiter-run)\n */\nexport class MarkdownSerializerState extends BaseMarkdownSerializerState {\n\n    inTable = false;\n\n    constructor(nodes, marks, options) {\n        super(nodes, marks, options ?? {});\n        this.inlines = [];\n    }\n\n    render(node, parent, index) {\n        super.render(node, parent, index);\n        const top = this.inlines[this.inlines.length - 1];\n        if(top?.start && top?.end) {\n            const { delimiter, start, end } = this.normalizeInline(top);\n            this.out = trimInline(this.out, delimiter, start, end);\n            this.inlines.pop();\n        }\n    }\n\n    markString(mark, open, parent, index) {\n        const info = this.marks[mark.type.name]\n        if(info.expelEnclosingWhitespace) {\n            if(open) {\n                this.inlines.push({\n                    start: this.out.length,\n                    delimiter: info.open,\n                });\n            } else {\n                const top = this.inlines.pop();\n                this.inlines.push({\n                    ...top,\n                    end: this.out.length,\n                });\n            }\n        }\n        return super.markString(mark, open, parent, index);\n    }\n\n    normalizeInline(inline) {\n        let { start, end } = inline;\n        while(this.out.charAt(start).match(/\\s/)) {\n            start++;\n        }\n        return {\n            ...inline,\n            start,\n        }\n    }\n}\n","import { Fragment } from \"@tiptap/pm/model\";\nimport { getHTMLFromFragment, Mark } from \"@tiptap/core\";\n\n\nexport default Mark.create({\n    name: 'markdownHTMLMark',\n    /**\n     * @return {{markdown: MarkdownMarkSpec}}\n     */\n    addStorage() {\n        return {\n            markdown: {\n                serialize: {\n                    open(state, mark)  {\n                        if(!this.editor.storage.markdown.options.html) {\n                            console.warn(`Tiptap Markdown: \"${mark.type.name}\" mark is only available in html mode`);\n                            return '';\n                        }\n                        return getMarkTags(mark)?.[0] ?? '';\n                    },\n                    close(state, mark) {\n                        if(!this.editor.storage.markdown.options.html) {\n                            return '';\n                        }\n                        return getMarkTags(mark)?.[1] ?? '';\n                    },\n                },\n                parse: {\n                    // handled by markdown-it\n                }\n            }\n        }\n    }\n});\n\nfunction getMarkTags(mark) {\n    const schema = mark.type.schema;\n    const node = schema.text(' ', [mark]);\n    const html = getHTMLFromFragment(Fragment.from(node), schema);\n    const match = html.match(/^(<.*?>) (<\\/.*?>)$/);\n    return match ? [match[1], match[2]] : null;\n}\n","\n\nexport function elementFromString(value) {\n    // add a wrapper to preserve leading and trailing whitespace\n    const wrappedValue = `<body>${value}</body>`\n\n    return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body\n}\n\nexport function escapeHTML(value) {\n    return value\n        ?.replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;');\n}\n\nexport function extractElement(node) {\n    const parent = node.parentElement;\n    const prepend = parent.cloneNode();\n\n    while(parent.firstChild && parent.firstChild !== node) {\n        prepend.appendChild(parent.firstChild);\n    }\n\n    if(prepend.childNodes.length > 0) {\n        parent.parentElement.insertBefore(prepend, parent);\n    }\n    parent.parentElement.insertBefore(node, parent);\n    if(parent.childNodes.length === 0) {\n        parent.remove();\n    }\n}\n\nexport function unwrapElement(node) {\n    const parent = node.parentNode;\n\n    while (node.firstChild) parent.insertBefore(node.firstChild, node);\n\n    parent.removeChild(node);\n}\n","import { Fragment } from \"@tiptap/pm/model\";\nimport { getHTMLFromFragment, Node } from \"@tiptap/core\";\nimport { elementFromString } from \"../../util/dom\";\n\n\nexport default Node.create({\n    name: 'markdownHTMLNode',\n    addStorage() {\n        return {\n            markdown: {\n                serialize(state, node, parent) {\n                    if(this.editor.storage.markdown.options.html) {\n                        state.write(serializeHTML(node, parent));\n                    } else {\n                        console.warn(`Tiptap Markdown: \"${node.type.name}\" node is only available in html mode`);\n                        state.write(`[${node.type.name}]`);\n                    }\n                    if(node.isBlock) {\n                        state.closeBlock(node);\n                    }\n                },\n                parse: {\n                    // handled by markdown-it\n                },\n            },\n        }\n    }\n});\n\nfunction serializeHTML(node, parent) {\n    const schema = node.type.schema;\n    const html = getHTMLFromFragment(Fragment.from(node), schema);\n\n    if(node.isBlock && (parent instanceof Fragment || parent.type.name === schema.topNodeType.name)) {\n        return formatBlock(html);\n    }\n\n    return html;\n}\n\n/**\n * format html block as per the commonmark spec\n */\nfunction formatBlock(html) {\n    const dom = elementFromString(html);\n    const element = dom.firstElementChild;\n\n    element.innerHTML = element.innerHTML.trim()\n        ? `\\n${element.innerHTML}\\n`\n        : `\\n`;\n\n    return element.outerHTML;\n}\n","import { Node } from \"@tiptap/core\";\nimport { defaultMarkdownSerializer } from \"prosemirror-markdown\";\n\n\nconst Blockquote = Node.create({\n    name: 'blockquote',\n});\n\nexport default Blockquote.extend({\n    /**\n     * @return {{markdown: MarkdownNodeSpec}}\n     */\n    addStorage() {\n        return {\n            markdown: {\n                serialize: defaultMarkdownSerializer.nodes.blockquote,\n                parse: {\n                    // handled by markdown-it\n                },\n            }\n        }\n    }\n});\n","import { Node } from \"@tiptap/core\";\n\n\nconst BulletList = Node.create({\n    name: 'bulletList',\n});\n\nexport default BulletList.extend({\n    /**\n     * @return {{markdown: MarkdownNodeSpec}}\n     */\n    addStorage() {\n        return {\n            markdown: {\n                serialize(state, node) {\n                    return state.renderList(node, \"  \", () => (this.editor.storage.markdown.options.bulletListMarker || \"-\") + \" \");\n                },\n                parse: {\n                    // handled by markdown-it\n                },\n            }\n        }\n    }\n});\n","import { Node } from \"@tiptap/core\";\n\n\nconst CodeBlock = Node.create({\n    name: 'codeBlock',\n});\n\nexport default CodeBlock.extend({\n    /**\n     * @return {{markdown: MarkdownNodeSpec}}\n     */\n    addStorage() {\n        return {\n            markdown: {\n                serialize(state, node) {\n                    state.write(\"```\" + (node.attrs.language || \"\") + \"\\n\");\n                    state.text(node.textContent, false);\n                    state.ensureNewLine();\n                    state.write(\"```\");\n                    state.closeBlock(node);\n                },\n                parse: {\n                    setup(marked) {\n                        // Set the language class prefix if needed\n                        // This maintains the same behavior as in markdown-it\n                        // Marked uses 'language-' prefix by default like markdown-it\n                        const langPrefix = this.options.languageClassPrefix ?? 'language-';\n                        if (langPrefix !== 'language-') {\n                            marked.setOptions({ langPrefix });\n                        }\n                    },\n                    updateDOM(element) {\n                        element.innerHTML = element.innerHTML.replace(/\\n<\\/code><\\/pre>/g, '</code></pre>')\n                    },\n                },\n            }\n        }\n    }\n});\n","import { Node } from \"@tiptap/core\";\nimport HTMLNode from './html';\n\nconst HardBreak = Node.create({\n    name: 'hardBreak',\n});\n\nexport default HardBreak.extend({\n    /**\n     * @return {{markdown: MarkdownNodeSpec}}\n     */\n    addStorage() {\n        return {\n            markdown: {\n                serialize(state, node, parent, index) {\n                    for (let i = index + 1; i < parent.childCount; i++)\n                        if (parent.child(i).type != node.type) {\n                            state.write(\n                                state.inTable\n                                    ? HTMLNode.storage.markdown.serialize.call(this, state, node, parent)\n                                    : \"\\\\\\n\"\n                            );\n                            return;\n                        }\n                },\n                parse: {\n                    // handled by markdown-it\n                },\n            }\n        }\n    }\n});\n","import { Node } from \"@tiptap/core\";\nimport { defaultMarkdownSerializer } from \"prosemirror-markdown\";\n\n\nconst Heading = Node.create({\n    name: 'heading',\n});\n\nexport default Heading.extend({\n    /**\n     * @return {{markdown: MarkdownNodeSpec}}\n     */\n    addStorage() {\n        return {\n            markdown: {\n                serialize: defaultMarkdownSerializer.nodes.heading,\n                parse: {\n                    // handled by markdown-it\n                },\n            }\n        }\n    }\n});\n","import { Node } from \"@tiptap/core\";\nimport { defaultMarkdownSerializer } from \"prosemirror-markdown\";\n\n\nconst HorizontalRule = Node.create({\n    name: 'horizontalRule',\n});\n\nexport default HorizontalRule.extend({\n    /**\n     * @return {{markdown: MarkdownNodeSpec}}\n     */\n    addStorage() {\n        return {\n            markdown: {\n                serialize: defaultMarkdownSerializer.nodes.horizontal_rule,\n                parse: {\n                    // handled by markdown-it\n                },\n            }\n        }\n    }\n});\n","import { Node } from \"@tiptap/core\";\nimport { defaultMarkdownSerializer } from \"prosemirror-markdown\";\n\n\nconst Image = Node.create({\n    name: 'image',\n});\n\nexport default Image.extend({\n    /**\n     * @return {{markdown: MarkdownNodeSpec}}\n     */\n    addStorage() {\n        return {\n            markdown: {\n                serialize: defaultMarkdownSerializer.nodes.image,\n                parse: {\n                    // handled by markdown-it\n                },\n            }\n        }\n    }\n});\n","import { Node } from \"@tiptap/core\";\nimport { defaultMarkdownSerializer } from \"prosemirror-markdown\";\n\n\nconst ListItem = Node.create({\n    name: 'listItem',\n});\n\nexport default ListItem.extend({\n    /**\n     * @return {{markdown: MarkdownNodeSpec}}\n     */\n    addStorage() {\n        return {\n            markdown: {\n                serialize: defaultMarkdownSerializer.nodes.list_item,\n                parse: {\n                    // handled by markdown-it\n                },\n            }\n        }\n    }\n});\n","import { Node } from \"@tiptap/core\";\n\n\nconst OrderedList = Node.create({\n    name: 'orderedList',\n});\n\nfunction findIndexOfAdjacentNode(node, parent, index) {\n    let i = 0;\n    for (; index - i > 0; i++) {\n        if (parent.child(index - i - 1).type.name !== node.type.name) {\n            break;\n        }\n    }\n    return i;\n}\n\nexport default OrderedList.extend({\n    /**\n     * @return {{markdown: MarkdownNodeSpec}}\n     */\n    addStorage() {\n        return {\n            markdown: {\n                serialize(state, node, parent, index) {\n                    const start = node.attrs.start || 1\n                    const maxW = String(start + node.childCount - 1).length\n                    const space = state.repeat(\" \", maxW + 2)\n                    const adjacentIndex = findIndexOfAdjacentNode(node, parent, index);\n                    const separator = adjacentIndex % 2 ? ') ' : '. ';\n                    state.renderList(node, space, i => {\n                        const nStr = String(start + i)\n                        return state.repeat(\" \", maxW - nStr.length) + nStr + separator;\n                    })\n                },\n                parse: {\n                    // handled by markdown-it\n                },\n            }\n        }\n    }\n});\n","import { Node } from \"@tiptap/core\";\nimport { defaultMarkdownSerializer } from \"prosemirror-markdown\";\n\n\nconst Paragraph = Node.create({\n    name: 'paragraph',\n});\n\nexport default Paragraph.extend({\n    /**\n     * @return {{markdown: MarkdownNodeSpec}}\n     */\n    addStorage() {\n        return {\n            markdown: {\n                serialize: defaultMarkdownSerializer.nodes.paragraph,\n                parse: {\n                    // handled by markdown-it\n                },\n            },\n        }\n    }\n});\n","\n\nexport function childNodes(node) {\n    return node?.content?.content ?? [];\n}\n","import { Node } from \"@tiptap/core\";\nimport { childNodes } from \"../../util/prosemirror\";\nimport HTMLNode from './html';\n\nconst Table = Node.create({\n    name: 'table',\n});\n\nexport default Table.extend({\n    /**\n     * @return {{markdown: MarkdownNodeSpec}}\n     */\n    addStorage() {\n        return {\n            markdown: {\n                serialize(state, node, parent) {\n                    if(!isMarkdownSerializable(node)) {\n                        HTMLNode.storage.markdown.serialize.call(this, state, node, parent);\n                        return;\n                    }\n                    state.inTable = true;\n                    node.forEach((row, p, i) => {\n                        state.write('| ');\n                        row.forEach((col, p, j) => {\n                            if(j) {\n                                state.write(' | ');\n                            }\n                            const cellContent = col.firstChild;\n                            if(cellContent.textContent.trim()) {\n                                state.renderInline(cellContent);\n                            }\n                        });\n                        state.write(' |')\n                        state.ensureNewLine();\n                        if(!i) {\n                            const delimiterRow = Array.from({length: row.childCount}).map(() => '---').join(' | ');\n                            state.write(`| ${delimiterRow} |`);\n                            state.ensureNewLine();\n                        }\n                    });\n                    state.closeBlock(node);\n                    state.inTable = false;\n                },\n                parse: {\n                    // handled by markdown-it\n                },\n            }\n        }\n    }\n})\n\n\nfunction hasSpan(node) {\n    return node.attrs.colspan > 1 || node.attrs.rowspan > 1;\n}\n\nfunction isMarkdownSerializable(node) {\n    const rows = childNodes(node);\n    const firstRow = rows[0];\n    const bodyRows = rows.slice(1);\n\n    if(childNodes(firstRow).some(cell => cell.type.name !== 'tableHeader' || hasSpan(cell) || cell.childCount > 1)) {\n        return false;\n    }\n\n    if(bodyRows.some(row =>\n        childNodes(row).some(cell => cell.type.name === 'tableHeader' || hasSpan(cell) || cell.childCount > 1)\n    )) {\n        return false;\n    }\n\n    return true;\n}\n","import { Node } from \"@tiptap/core\";\nimport { escapeHTML } from \"../../util/dom\";\n\n\nconst Text = Node.create({\n    name: 'text',\n});\n\nexport default Text.extend({\n    /**\n     * @return {{markdown: MarkdownNodeSpec}}\n     */\n    addStorage() {\n        return {\n            markdown: {\n                serialize(state, node) {\n                    state.text(escapeHTML(node.text));\n                },\n                parse: {\n                    // handled by markdown-it\n                },\n            }\n        }\n    }\n});\n","import { Mark } from \"@tiptap/core\";\nimport { defaultMarkdownSerializer } from \"prosemirror-markdown\";\n\n\nconst Bold = Mark.create({\n    name: 'bold',\n});\n\nexport default Bold.extend({\n    /**\n     * @return {{markdown: MarkdownMarkSpec}}\n     */\n    addStorage() {\n        return {\n            markdown: {\n                serialize: defaultMarkdownSerializer.marks.strong,\n                parse: {\n                    // handled by markdown-it\n                }\n            },\n        }\n    }\n});\n","import { Mark } from \"@tiptap/core\";\nimport { defaultMarkdownSerializer } from \"prosemirror-markdown\";\n\n\nconst Code = Mark.create({\n    name: 'code',\n});\n\nexport default Code.extend({\n    /**\n     * @return {{markdown: MarkdownMarkSpec}}\n     */\n    addStorage() {\n        return {\n            markdown: {\n                serialize: defaultMarkdownSerializer.marks.code,\n                parse: {\n                    // handled by markdown-it\n                }\n            }\n        }\n    }\n})\n","import { Mark } from \"@tiptap/core\";\nimport { defaultMarkdownSerializer } from \"prosemirror-markdown\";\n\n\nconst Italic = Mark.create({\n    name: 'italic',\n});\n\nexport default Italic.extend({\n    /**\n     * @return {{markdown: MarkdownMarkSpec}}\n     */\n    addStorage() {\n        return {\n            markdown: {\n                serialize: defaultMarkdownSerializer.marks.em,\n                parse: {\n                    // handled by markdown-it\n                }\n            }\n        }\n    }\n})\n","import { Mark } from \"@tiptap/core\";\nimport { defaultMarkdownSerializer } from \"prosemirror-markdown\";\n\n\nconst Link = Mark.create({\n    name: 'link',\n});\n\nexport default Link.extend({\n    /**\n     * @return {{markdown: MarkdownMarkSpec}}\n     */\n    addStorage() {\n        return {\n            markdown: {\n                serialize: defaultMarkdownSerializer.marks.link,\n                parse: {\n                    // handled by markdown-it\n                }\n            }\n        }\n    }\n})\n","import { Mark } from \"@tiptap/core\";\n\n\nconst Strike = Mark.create({\n    name: 'strike',\n});\n\nexport default Strike.extend({\n    /**\n     * @return {{markdown: MarkdownMarkSpec}}\n     */\n    addStorage() {\n        return {\n            markdown: {\n                serialize: {open: '~~', close: '~~', expelEnclosingWhitespace: true},\n                parse: {\n                    // handled by markdown-it\n                },\n            },\n        }\n    }\n});\n","import Blockquote from \"./nodes/blockquote\";\nimport BulletList from \"./nodes/bullet-list\";\nimport CodeBlock from \"./nodes/code-block\";\nimport HardBreak from \"./nodes/hard-break\";\nimport Heading from \"./nodes/heading\";\nimport HorizontalRule from \"./nodes/horizontal-rule\";\nimport HTMLNode from \"./nodes/html\";\nimport Image from \"./nodes/image\";\nimport ListItem from \"./nodes/list-item\";\nimport OrderedList from \"./nodes/ordered-list\";\nimport Paragraph from \"./nodes/paragraph\";\nimport Table from \"./nodes/table\";\nimport Text from \"./nodes/text\";\n\nimport Bold from \"./marks/bold\";\nimport Code from \"./marks/code\";\nimport HTMLMark from \"./marks/html\";\nimport Italic from \"./marks/italic\";\nimport Link from \"./marks/link\";\nimport Strike from \"./marks/strike\";\n\n\nexport default [\n    Blockquote,\n    BulletList,\n    CodeBlock,\n    HardBreak,\n    Heading,\n    HorizontalRule,\n    HTMLNode,\n    Image,\n    ListItem,\n    OrderedList,\n    Paragraph,\n    Table,\n    Text,\n\n    Bold,\n    Code,\n    HTMLMark,\n    Italic,\n    Link,\n    Strike,\n]\n","import markdownExtensions from \"../extensions\";\n\n\nexport function getMarkdownSpec(extension) {\n    const markdownSpec = extension.storage?.markdown;\n    const defaultMarkdownSpec = markdownExtensions.find(e => e.name === extension.name)?.storage.markdown;\n\n    if(markdownSpec || defaultMarkdownSpec) {\n        return {\n            ...defaultMarkdownSpec,\n            ...markdownSpec,\n        };\n    }\n\n    return null;\n}\n","import { MarkdownSerializerState } from './state';\nimport HTMLMark from \"../extensions/marks/html\";\nimport HTMLNode from \"../extensions/nodes/html\";\nimport { getMarkdownSpec } from \"../util/extensions\";\nimport HardBreak from \"../extensions/nodes/hard-break\";\n\n\nexport class MarkdownSerializer {\n    /**\n     * @type {import('@tiptap/core').Editor}\n     */\n    editor = null;\n\n    constructor(editor) {\n        this.editor = editor;\n    }\n    \n    /**\n     * Clean up resources to prevent memory leaks\n     */\n    destroy() {\n        this.editor = null;\n    }\n\n    serialize(content) {\n        const state = new MarkdownSerializerState(this.nodes, this.marks, {\n            hardBreakNodeName: HardBreak.name,\n        });\n\n        state.renderContent(content);\n\n        return state.out;\n    }\n\n    get nodes() {\n        return {\n            ...Object.fromEntries(\n                Object.keys(this.editor.schema.nodes)\n                    .map(name => [name, this.serializeNode(HTMLNode)])\n            ),\n            ...Object.fromEntries(\n                this.editor.extensionManager.extensions\n                    .filter(extension => extension.type === 'node' && this.serializeNode(extension))\n                    .map(extension => [extension.name, this.serializeNode(extension)])\n                ?? []\n            ),\n        };\n    }\n\n    get marks() {\n        return {\n            ...Object.fromEntries(\n                Object.keys(this.editor.schema.marks)\n                    .map(name => [name, this.serializeMark(HTMLMark)])\n            ),\n            ...Object.fromEntries(\n                this.editor.extensionManager.extensions\n                    .filter(extension => extension.type === 'mark' && this.serializeMark(extension))\n                    .map(extension => [extension.name, this.serializeMark(extension)])\n                ?? []\n            ),\n        };\n    }\n\n    serializeNode(node) {\n        return getMarkdownSpec(node)?.serialize?.bind({ editor: this.editor, options: node.options });\n    }\n\n    serializeMark(mark) {\n        const serialize = getMarkdownSpec(mark)?.serialize;\n        return serialize\n            ? {\n                ...serialize,\n                open: typeof serialize.open === 'function' ? serialize.open.bind({ editor: this.editor, options: mark.options }) : serialize.open,\n                close: typeof serialize.close === 'function' ? serialize.close.bind({ editor: this.editor, options: mark.options }) : serialize.close,\n            }\n            : null\n    }\n}\n\n","import { marked } from 'marked';\nimport { elementFromString, extractElement, unwrapElement } from \"../util/dom\";\nimport { getMarkdownSpec } from \"../util/extensions\";\nimport { cleanupMarkedParser } from \"../util/markdown\";\n\n// Use a weak cache to avoid recomputing selectors\nconst blockSelectorCache = new WeakMap();\n\nexport class MarkdownParser {\n    /**\n     * @type {import('@tiptap/core').Editor}\n     */\n    editor = null;\n    \n    // Track destruction state\n    destroyed = false;\n    \n    // Use a function-based approach instead of storing the parser\n    parseMarkdown = null;\n    parseMarkdownInline = null;\n\n    constructor(editor, { html, linkify, breaks }) {\n        this.editor = editor;\n        \n        // Configure marked options to match markdown-it behavior\n        const markedOptions = {\n            headerIds: false, // Don't add IDs to headings\n            mangle: false,    // Don't mangle header IDs\n            breaks: breaks,   // Line breaks behavior\n            gfm: true,        // GitHub Flavored Markdown\n            linkify: linkify, // Linkify functionality\n            // Handle HTML option explicitly\n            html: html !== false, // Allow HTML by default to match markdown-it's default behavior when html=true\n            silent: false,\n            // In marked, linkify functionality is part of GFM\n        };\n        \n        // Store the parsing functions directly, don't keep a reference to marked\n        this.parseMarkdown = this.withPatchedRenderer((text) => {\n            // Reset options before each parse to ensure clean state\n            marked.setOptions(markedOptions);\n            return marked.parse(text);\n        });\n        \n        this.parseMarkdownInline = this.withPatchedRenderer((text) => {\n            // Reset options before each parse to ensure clean state\n            marked.setOptions(markedOptions);\n            return marked.parseInline(text);\n        });\n        \n        // Add event listener for cleanup\n        this.destroyHandler = () => this.destroy();\n        this.editor.on('destroy', this.destroyHandler);\n    }\n\n    /**\n     * Cleanup resources to prevent memory leaks\n     */\n    destroy() {\n        if (this.destroyed) return;\n        this.destroyed = true;\n        \n        // Remove event listener\n        if (this.editor && this.destroyHandler) {\n            this.editor.off('destroy', this.destroyHandler);\n            this.destroyHandler = null;\n        }\n        \n        // Release all references\n        this.parseMarkdown = null;\n        this.parseMarkdownInline = null;\n        this.editor = null;\n        \n        // Clean up the marked parser\n        cleanupMarkedParser();\n    }\n\n    parse(content, { inline } = {}) {\n        if (this.destroyed) return content;\n        \n        if (typeof content === 'string') {\n            try {\n                // Call appropriate parse method based on context\n                const renderedHTML = inline \n                    ? this.parseMarkdownInline(content)\n                    : this.parseMarkdown(content);\n                \n                // Create DOM from HTML string    \n                const element = elementFromString(renderedHTML);\n                \n                // Allow extensions to modify the DOM\n                const extensions = this.editor.extensionManager.extensions;\n                for (let i = 0; i < extensions.length; i++) {\n                    const extension = extensions[i];\n                    const spec = getMarkdownSpec(extension);\n                    if (spec?.parse?.updateDOM) {\n                        spec.parse.updateDOM.call(\n                            { editor: this.editor, options: extension.options }, \n                            element\n                        );\n                    }\n                }\n                \n                // Normalize the DOM structure\n                this.normalizeDOM(element, { inline, content });\n                \n                // Get HTML and help GC by breaking references\n                const result = element.innerHTML;\n                \n                return result;\n            } catch (e) {\n                console.error('Error parsing markdown:', e);\n                return content;\n            }\n        }\n        \n        return content;\n    }\n\n    normalizeDOM(node, { inline, content }) {\n        if (!node || this.destroyed) return node;\n        \n        try {\n            this.normalizeBlocks(node);\n            \n            // More efficient query selection with a single querySelectorAll call\n            const elements = node.querySelectorAll('*');\n            for (let i = 0; i < elements.length; i++) {\n                const el = elements[i];\n                const nextSibling = el.nextSibling;\n                if (nextSibling?.nodeType === Node.TEXT_NODE && !el.closest('pre')) {\n                    nextSibling.textContent = nextSibling.textContent.replace(/^\\n/, '');\n                }\n            }\n            \n            if (inline) {\n                this.normalizeInline(node, content);\n            }\n            \n            return node;\n        } catch (e) {\n            console.error('Error normalizing DOM:', e);\n            return node;\n        }\n    }\n\n    normalizeBlocks(node) {\n        // Use cached selector for better performance\n        let selector = null;\n        \n        if (!blockSelectorCache.has(this.editor.schema)) {\n            const blocks = Object.values(this.editor.schema.nodes)\n                .filter(node => node.isBlock);\n                \n            selector = blocks\n                .map(block => block.spec.parseDOM?.map(spec => spec.tag))\n                .flat()\n                .filter(Boolean)\n                .join(',');\n                \n            // Cache the selector for future use\n            blockSelectorCache.set(this.editor.schema, selector);\n        } else {\n            selector = blockSelectorCache.get(this.editor.schema);\n        }\n        \n        if (!selector) {\n            return;\n        }\n        \n        // Use a more memory-efficient approach by avoiding array creation\n        const elements = node.querySelectorAll(selector);\n        for (let i = 0; i < elements.length; i++) {\n            const el = elements[i];\n            if (el.parentElement?.matches('p')) {\n                extractElement(el);\n            }\n        }\n    }\n\n    normalizeInline(node, content) {\n        if (node.firstElementChild?.matches('p')) {\n            const firstParagraph = node.firstElementChild;\n            const nextElementSibling = firstParagraph.nextElementSibling;\n            \n            // Optimize regex operations\n            let startSpaces = '';\n            let endSpaces = '';\n            \n            const startMatch = /^\\s+/.exec(content);\n            if (startMatch) startSpaces = startMatch[0];\n            \n            if (!nextElementSibling) {\n                const endMatch = /\\s+$/.exec(content);\n                if (endMatch) endSpaces = endMatch[0];\n            }\n            \n            if (/^\\n\\n/.test(content)) {\n                firstParagraph.innerHTML = `${firstParagraph.innerHTML}${endSpaces}`;\n                return;\n            }\n            \n            unwrapElement(firstParagraph);\n            \n            node.innerHTML = `${startSpaces}${node.innerHTML}${endSpaces}`;\n        }\n    }\n\n    /**\n     * Patch the renderer to handle newlines correctly\n     */\n    withPatchedRenderer(renderFn) {\n        return (text) => {\n            try {\n                const rendered = renderFn(text);\n                \n                // Don't modify soft breaks\n                if (rendered === '\\n') {\n                    return rendered;\n                }\n                \n                // Remove trailing newlines\n                if (rendered.endsWith('\\n')) {\n                    return rendered.slice(0, -1);\n                }\n                \n                return rendered;\n            } catch (e) {\n                console.error('Error in renderer:', e);\n                // Return original text as fallback\n                return text;\n            }\n        };\n    }\n}\n\n","import { Extension } from \"@tiptap/core\";\nimport { Plugin, PluginKey } from '@tiptap/pm/state';\nimport { DOMParser } from '@tiptap/pm/model';\nimport { elementFromString } from \"../../util/dom\";\n\nexport const MarkdownClipboard = Extension.create({\n    name: 'markdownClipboard',\n    addOptions() {\n        return {\n            transformPastedText: false,\n            transformCopiedText: false,\n        }\n    },\n    addProseMirrorPlugins() {\n        return [\n            new Plugin({\n                key: new PluginKey('markdownClipboard'),\n                props: {\n                    clipboardTextParser: (text, context, plainText) => {\n                        if(plainText || !this.options.transformPastedText || !this.editor.storage.markdown) {\n                            return null; // pasting with shift key prevents formatting\n                        }\n                        const parsed = this.editor.storage.markdown.parser.parse(text, { inline: true });\n                        return DOMParser.fromSchema(this.editor.schema)\n                            .parseSlice(elementFromString(parsed), {\n                                preserveWhitespace: true,\n                                context,\n                            });\n                    },\n                    /**\n                     * @param {import('prosemirror-model').Slice} slice\n                     */\n                    clipboardTextSerializer: (slice) => {\n                        if(!this.options.transformCopiedText || !this.editor.storage.markdown) {\n                            return null;\n                        }\n                        return this.editor.storage.markdown.serializer.serialize(slice.content);\n                    },\n                },\n            })\n        ]\n    }\n})\n","import { Extension, extensions } from '@tiptap/core';\nimport { MarkdownTightLists } from \"./extensions/tiptap/tight-lists\";\nimport { MarkdownSerializer } from \"./serialize/MarkdownSerializer\";\nimport { MarkdownParser } from \"./parse/MarkdownParser\";\nimport { MarkdownClipboard } from \"./extensions/tiptap/clipboard\";\nimport { cleanupMarkedParser } from \"./util/markdown\";\n\n// Use WeakRef to track extensions without preventing garbage collection\nconst activeExtensions = new Set();\n\n// Global cleanup mechanism\nlet globalCleanupTimer = null;\nfunction scheduleGlobalCleanup() {\n    if (globalCleanupTimer) {\n        clearTimeout(globalCleanupTimer);\n    }\n    \n    globalCleanupTimer = setTimeout(() => {\n        // Run a garbage collection cycle on inactive extensions\n        activeExtensions.forEach(weakRef => {\n            const extension = weakRef.deref();\n            if (!extension || !extension.editor) {\n                activeExtensions.delete(weakRef);\n            }\n        });\n        \n        // If no extensions remain, clean up global resources\n        if (activeExtensions.size === 0) {\n            cleanupMarkedParser();\n        }\n        \n        globalCleanupTimer = null;\n    }, 30000); // 30 second delay\n}\n\nexport const Markdown = Extension.create({\n    name: 'markdown',\n    priority: 50,\n    addOptions() {\n        return {\n            html: true,\n            tightLists: true,\n            tightListClass: 'tight',\n            bulletListMarker: '-',\n            linkify: false,\n            breaks: false,\n            transformPastedText: false,\n            transformCopiedText: false,\n        }\n    },\n    addCommands() {\n        const commands = extensions.Commands.config.addCommands();\n        return {\n            setContent: (content, emitUpdate, parseOptions) => (props) => {\n                if (!props.editor?.storage?.markdown?.parser) return false;\n                \n                try {\n                    const html = props.editor.storage.markdown.parser.parse(content);\n                    return commands.setContent(html, emitUpdate, parseOptions)(props);\n                } catch (e) {\n                    console.error('Error setting content:', e);\n                    return false;\n                }\n            },\n            insertContentAt: (range, content, options) => (props) => {\n                if (!props.editor?.storage?.markdown?.parser) return false;\n                \n                try {\n                    const html = props.editor.storage.markdown.parser.parse(content, { inline: true });\n                    return commands.insertContentAt(range, html, options)(props);\n                } catch (e) {\n                    console.error('Error inserting content:', e);\n                    return false;\n                }\n            },\n        }\n    },\n    onBeforeCreate() {\n        // Track this extension using WeakRef\n        const weakRef = new WeakRef(this);\n        activeExtensions.add(weakRef);\n        \n        // Schedule cleanup periodically\n        scheduleGlobalCleanup();\n        \n        // Set up storage with the parser and serializer\n        this.editor.storage.markdown = {\n            options: { ...this.options },\n            parser: new MarkdownParser(this.editor, this.options),\n            serializer: new MarkdownSerializer(this.editor),\n            getMarkdown: null, // Will be initialized below\n        };\n        \n        // Define getMarkdown as a function that doesn't capture this\n        this.editor.storage.markdown.getMarkdown = () => {\n            const editor = this.editor;\n            if (!editor?.storage?.markdown?.serializer || !editor.state?.doc) {\n                return '';\n            }\n            \n            try {\n                return editor.storage.markdown.serializer.serialize(editor.state.doc);\n            } catch (e) {\n                console.error('Error serializing markdown:', e);\n                return '';\n            }\n        };\n        \n        // Save initial content and parse it\n        this.editor.options.initialContent = this.editor.options.content;\n        \n        try {\n            const parsedContent = this.editor.storage.markdown.parser.parse(this.editor.options.content);\n            this.editor.options.content = parsedContent;\n        } catch (e) {\n            console.error('Error parsing initial content:', e);\n            // Keep original content if parsing fails\n        }\n    },\n    onCreate() {\n        if (this.editor.options.initialContent !== undefined) {\n            this.editor.options.content = this.editor.options.initialContent;\n            delete this.editor.options.initialContent;\n        }\n    },\n    onDestroy() {\n        // Ensure proper cleanup when the editor is destroyed\n        try {\n            // Clean up parser if it has a destroy method\n            if (this.editor?.storage?.markdown?.parser?.destroy) {\n                this.editor.storage.markdown.parser.destroy();\n            }\n            \n            // Clean up references to break potential circular references\n            if (this.editor?.storage?.markdown) {\n                // Clear each property individually\n                if (this.editor.storage.markdown.serializer) {\n                    this.editor.storage.markdown.serializer.editor = null;\n                    this.editor.storage.markdown.serializer = null;\n                }\n                \n                this.editor.storage.markdown.parser = null;\n                this.editor.storage.markdown.getMarkdown = null;\n                this.editor.storage.markdown.options = null;\n                this.editor.storage.markdown = null;\n            }\n            \n            // Schedule a cleanup to check if all extensions are gone\n            scheduleGlobalCleanup();\n        } catch (e) {\n            console.error('Error during Markdown extension cleanup:', e);\n        }\n    },\n    addStorage() {\n        return {\n            /// storage will be defined in onBeforeCreate() to prevent initial object overriding\n        }\n    },\n    addExtensions() {\n        return [\n            MarkdownTightLists.configure({\n                tight: this.options.tightLists,\n                tightClass: this.options.tightListClass,\n            }),\n            MarkdownClipboard.configure({\n                transformPastedText: this.options.transformPastedText,\n                transformCopiedText: this.options.transformCopiedText,\n            }),\n        ]\n    },\n});\n"],"names":["MarkdownTightLists","Extension","create","name","addOptions","tight","tightClass","listTypes","addGlobalAttributes","types","options","attributes","default","parseHTML","element","getAttribute","querySelector","renderHTML","class","addCommands","_this","toggleTight","arguments","length","undefined","_ref","editor","commands","isActive","attrs","getAttributes","updateAttributes","some","parserSymbol","Symbol","cleanupMarkedParser","globalThis","canDelimiterBeUsed","text","pos","isOpening","charAt","prevCharCode","charCodeAt","nextCharCode","isPrevWhitespace","isNextWhitespace","isPrevPunctuation","isPunctuation","isNextPunctuation","charCode","shiftDelim","delim","start","offset","substring","trimStart","from","to","res","maxIterations","iterations","trimEnd","trimInline","state","e","console","error","MarkdownSerializerState","BaseMarkdownSerializerState","constructor","nodes","marks","inTable","inlines","render","node","parent","index","top","end","delimiter","normalizeInline","out","pop","markString","mark","open","info","type","expelEnclosingWhitespace","push","inline","match","Mark","addStorage","markdown","serialize","_getMarkTags$","_getMarkTags","storage","html","warn","getMarkTags","close","_getMarkTags$2","_getMarkTags2","parse","schema","getHTMLFromFragment","Fragment","elementFromString","value","wrappedValue","window","DOMParser","parseFromString","body","escapeHTML","replace","extractElement","parentElement","prepend","cloneNode","firstChild","appendChild","childNodes","insertBefore","remove","unwrapElement","parentNode","removeChild","Node","write","serializeHTML","isBlock","closeBlock","topNodeType","formatBlock","dom","firstElementChild","innerHTML","trim","outerHTML","Blockquote","extend","defaultMarkdownSerializer","blockquote","BulletList","renderList","bulletListMarker","CodeBlock","language","textContent","ensureNewLine","setup","marked","_this$options$languag","langPrefix","languageClassPrefix","setOptions","updateDOM","HardBreak","i","childCount","child","HTMLNode","call","Heading","heading","HorizontalRule","horizontal_rule","Image","image","ListItem","list_item","OrderedList","findIndexOfAdjacentNode","maxW","String","space","repeat","adjacentIndex","separator","nStr","Paragraph","paragraph","_node$content$content","_node$content","content","Table","isMarkdownSerializable","forEach","row","p","col","j","cellContent","renderInline","delimiterRow","Array","map","join","hasSpan","colspan","rowspan","rows","firstRow","bodyRows","slice","cell","Text","Bold","strong","Code","code","Italic","em","Link","link","Strike","HTMLMark","getMarkdownSpec","extension","_extension$storage","_markdownExtensions$f","markdownSpec","defaultMarkdownSpec","markdownExtensions","find","MarkdownSerializer","destroy","hardBreakNodeName","renderContent","_this$editor$extensio","Object","fromEntries","keys","serializeNode","extensionManager","extensions","filter","_this$editor$extensio2","serializeMark","_getMarkdownSpec","bind","_getMarkdownSpec2","blockSelectorCache","WeakMap","MarkdownParser","destroyed","parseMarkdown","parseMarkdownInline","linkify","breaks","markedOptions","headerIds","mangle","gfm","silent","withPatchedRenderer","parseInline","destroyHandler","on","off","renderedHTML","_spec$parse","spec","normalizeDOM","result","_ref2","normalizeBlocks","elements","querySelectorAll","el","nextSibling","nodeType","TEXT_NODE","closest","selector","has","blocks","values","block","_block$spec$parseDOM","parseDOM","tag","flat","Boolean","set","get","_el$parentElement","matches","_node$firstElementChi","firstParagraph","nextElementSibling","startSpaces","endSpaces","startMatch","exec","endMatch","test","renderFn","rendered","endsWith","MarkdownClipboard","transformPastedText","transformCopiedText","addProseMirrorPlugins","Plugin","key","PluginKey","props","clipboardTextParser","context","plainText","parsed","parser","fromSchema","parseSlice","preserveWhitespace","clipboardTextSerializer","serializer","activeExtensions","Set","globalCleanupTimer","scheduleGlobalCleanup","clearTimeout","setTimeout","weakRef","deref","delete","size","Markdown","priority","tightLists","tightListClass","Commands","config","setContent","emitUpdate","parseOptions","_props$editor","insertContentAt","range","_props$editor2","onBeforeCreate","WeakRef","add","getMarkdown","_editor$storage","_editor$state","doc","initialContent","parsedContent","onCreate","onDestroy","_this$editor","_this$editor2","addExtensions","configure"],"mappings":"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"}